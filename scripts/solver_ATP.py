'''
This code is used in the script "BayesOpt_impulse_calibration" to compute the numerical
solution of the monodomain model coupled with the Rogers-McCulloch model for the ionic current, 
including the effect of an impulse generated by an Anti-tachycardia pacing (ATP) device
at time "ATP_time" [ms] and lasting "ATP_duration" milliseconds. Since the computation of the numerical ECG
is costly, the solver we modified has some perks which, for example, allow to compute the numerical ECG
before the ATP impulse only once, then store it and use it to advance in time whenever the behaviour of the ECG
after the impulse is needed. In the following, we report the meaning of the inputs of the solver:
    - ATP_time, ATP_duration (float): parameters of the impulse w.r.t which we want to compute the ECG.
    - best_nu (list(float)): contains the best patient-specific values for hyperparameter nu_2.
    - idx (int): index of the patient we want to compute the numerical ECG of.
    - max_time (int, default 800): final instant of the simulation.
    - patients (int, default 3): number of patients to deal with.
    - verbose (int, default 1): used to suppress prints.
    - Flag (bool, default True): if True, then we want the solver to solve the ECG up to max_time and to save the initial values
                                 (i.e. the ones just before the ECG) in a dedicated folder. If False, then it solves the ECG up to max_time,
                                 but now instead of saving the initial values, it loads them from the previously created directory.
    - starting_time_ecg (int, default 0): startin point of the simulation.
'''

# Import libraries
import os
import pickle
import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.animation import FuncAnimation
from tqdm import tqdm
from sklearn.metrics import mean_squared_error

def solver_ATP(ATP_time, ATP_duration, best_nu, idx, max_time = 800, patients = 3,  verbose = 1, Flag =True, starting_time_ecg = 0):
    def plotsolution(u_k, k):
        plt.clf()
    
        plt.title(f"Solution at t = {k*delta_t:.3f} ms")
        plt.xlabel("x")
        plt.ylabel("y")
    
        plt.pcolormesh(u_k, cmap=plt.cm.jet ,vmin=0, vmax=100 )
        plt.colorbar()
    
        plt.axis('equal')
    
        plt.show(block=False)
        plt.pause(0.01)
    
        return plt
    
    # inner functions for differentiation
    def make_kernel(a):
      """Transform a 2D array into a convolution kernel"""
      a = np.asarray(a)
      a = a.reshape(list(a.shape) + [1,1])
      return tf.constant(a, dtype=1)
    
    def simple_conv(x, k):
      """A simplified 2D convolution operation"""
      x = tf.expand_dims(tf.expand_dims(x, 0), -1)
      y = tf.nn.depthwise_conv2d(x, k, [1, 1, 1, 1], padding='SAME')
      return y[0, :, :, 0]
    
    def laplace(x):
      """Compute the 2D laplacian of an array"""
      laplace_iso_k = make_kernel([[0.25, 0.5, 0.25],
                               [0.5, -3., 0.5],
                               [0.25, 0.5, 0.25]])
      laplace_k = make_kernel([[0.0, 1.0, 0.0],
                               [1.0, -4.0, 1.0],
                               [0.0, 1.0, 0.0]])
      return simple_conv(x, laplace_iso_k)
    
    def laplace_fiber(x):
      """Compute the 2D laplacian of an array"""
      laplace_fib_k = make_kernel([[0.0, 1.0, 0.0],
                               [0, -2., 0.0],
                               [0.0, 1.0, 0.0]])
      return simple_conv(x, laplace_fib_k)
    
    def diff_y(x):
      """Compute the 2D laplacian of an array"""
      diff_k = make_kernel([[0.0, 0.5, 0.0],
                               [0, 0.0, 0.0],
                               [0.0, -0.5, 0.0]])
      return simple_conv(x, diff_k)
    
    def diff_x(x):
      """Compute the 2D laplacian of an array"""
      diff_k = make_kernel([[0.0, 0.0, 0.0],
                               [-0.5, 0.0, 0.5],
                               [0.0, 0.0, 0.0]])
      return simple_conv(x, diff_k)

    
    # space discretization
    N = np.int32(128) # discretization on y
    M = np.int32(64) # discretization on x
    h = 2/N # mesh size on y
    
    # time discretization
    delta_t = tf.constant(0.01,dtype=tf.float32, shape=()) # time discretization-> size: delta_t =0.01
    max_iter_time = np.int32(max_time/delta_t)+1 # np.int32(800/delta_t)+1 #n max number of iterations
    scaling_factor = np.int32(1.0/delta_t)
    
    Trigger = 322 #[ms]
    S2 = Trigger/delta_t 
    num_sim = patients # number of simulations
    
    # initialization
    signals = np.zeros([num_sim,3,np.int32(max_iter_time/scaling_factor)+1], dtype=np.float32)
    #array of shape: number of simulations x 3 x 800+delta_t+1
    
    for ind_sim in range(num_sim): 
        if num_sim > 1:
            print("------------------------")
            print("elaborating patient ", ind_sim+1)
            print("------------------------")
        # timing of shock
        ICD_time      = np.int32( ATP_time/delta_t ) 
        # duration of the shock
        ICD_duration  = ATP_duration 
        # amplitude of the shock
        ICD_amplitude = 1.0
    
        # Initial Condition
        ut_init   = np.zeros([N, M], dtype=np.float32)
        Iapp_IC   = np.zeros([N, M], dtype=np.float32)
        Iapp_init = np.zeros([N, M], dtype=np.float32)
        Iapp_ICD  = np.zeros([N, M], dtype=np.float32)
        r_coeff = 1.2 + np.zeros([N, M], dtype=np.float32)
    
        distance_matrix_1 = np.zeros([N, M], dtype=np.float32) # 0.05+1.95*np.random.rand(N, N)
        distance_matrix_2 = np.zeros([N, M], dtype=np.float32) # 0.05+1.95*np.random.rand(N, N)
        for i in range(N):
            for j in range(M):
                distance_matrix_1[i,j] = 1/(np.sqrt( (i*h-1)**2  + (j*h-1.25)**2))
                distance_matrix_2[i,j] = 1/(np.sqrt( (i*h-1)**2  + (j*h+0.25)**2))
    
        Iapp_init[np.int32(N/2-0.4/h):np.int32(N/2+0.4/h),np.int32(M/2-0.15/h):np.int32(M/2+0.15/h)] = 1.0
        Iapp_ICD[0:np.int32(0.25/h),np.int32(0.5/h):np.int32(0.65/h)] = 1.0
        Iapp_ICD[N-np.int32(0.25/h):N-1,np.int32(0.5/h):np.int32(0.65/h)] = 1.0
    
    
        Iapp_IC[:,0:np.int32(0.05/h)] = 100.0 
        Ulist = []
    
        # physical coefficients
        nu_0 = tf.constant(1.5,dtype=tf.float32, shape=())
        nu_1 = tf.constant(4.4,dtype=tf.float32, shape=())
        nu_2 = tf.constant(best_nu[ind_sim],dtype=tf.float32, shape=())
        nu_3 = tf.constant(1.0,dtype=tf.float32, shape=())
        v_th = tf.constant(13,dtype=tf.float32, shape=())
        v_pk = tf.constant(100,dtype=tf.float32, shape=())
        D_1 = tf.constant(0.003/(h**2),dtype=tf.float32, shape=())
        D_2 = tf.constant(0.000315/(h**2),dtype=tf.float32, shape=())
    
        # Create variables for simulation
        Ut   = tf.Variable(ut_init) # potential
        Wt   = tf.Variable(0*ut_init) # gating variable
        Iapp = tf.Variable(Iapp_init)
        IappICD = tf.Variable(Iapp_ICD) 
        IappIC = tf.Variable(Iapp_IC) 
        Dr = tf.Variable(r_coeff, dtype=np.float32)
    
        Ulist.append(Ut)
    
        # time advancing
        if Flag == False:

            for i in tqdm(range(max_iter_time)):

                if Flag == False and i == 450/delta_t:
                    # save Ulist
                    with open("initial_values"+ os.sep + "Patient_" + str(idx+1) + "_Ulist.npy", "wb") as fp:  # Pickling
                        pickle.dump(Ulist, fp)
                    #save Ut
                    np.save("initial_values"+ os.sep + "Patient_" + str(idx+1) + "_Ut.npy", Ut, allow_pickle= True)
                    #save Wt
                    np.save("initial_values"+ os.sep + "Patient_" + str(idx+1) + "_Wt.npy", Wt, allow_pickle= True)

                if ((i > -1) & (i < 1+np.int32(2/delta_t)) ) | \
                    ((i > np.int32(200/delta_t)) & (i < np.int32(202/delta_t)) ) :
                    #coeff_init = ((128/N)**2)*10.0*0.02/delta_t
                    coeff_init = 10.0
                else:
                    coeff_init = 0.0

                # extra-stim-> [322, 324]
                if (i > S2) & (i < S2+np.int32(2/delta_t)):
                    #coeff = ((128/N)**2)*100.0*0.02/delta_t
                    coeff = 100.0
                else:
                    coeff = 0.0

                # ATP impulse-> [460, 460 + duration ICD(5)]
                if (i > ICD_time) & (i < ICD_time+np.int32(ICD_duration/delta_t)):
                    # coeff_ICD = ICD_amplitude*((128/N)**2)*100.0*0.02/delta_t
                    coeff_ICD = 100
                else:
                    coeff_ICD = 0.0

                # nonlinear terms
                I_ion = nu_0*Ut*(1.0-Ut/v_th)*(1.0-Ut/v_pk) + nu_1*Wt*Ut # Roger-McCulloch model for the ionic current
                g_ion = nu_2*(Ut/v_pk-nu_3*Wt) 

                # update the solution
                Ut = Ut + delta_t * (  Dr*D_2 * laplace(Ut) + Dr*(D_1-D_2)*laplace_fiber(Ut)  \
                        - I_ion + coeff_init*IappIC + coeff*Iapp + coeff_ICD*IappICD )
                Wt = Wt + delta_t *  g_ion

                # ghost nodes
                tmp_u = Ut.numpy()

                tmp_u[0,:]    = tmp_u[2,:]
                tmp_u[N-1,:]  = tmp_u[N-3,:]
                tmp_u[:,0]    = tmp_u[:,2]
                tmp_u[:,M-1]  = tmp_u[:,M-3]

                Ut = tf.Variable(tmp_u)

                Ulist.append(Ut)
                k = np.int32(i / scaling_factor)
                if (np.mod(i, scaling_factor) == 0):
                    # pseudo ECG
                    if i >= starting_time_ecg/delta_t:

                        signals[ind_sim, 0, k] = 1 / (h ** 2) * np.sum(
                            diff_x(Ulist[i][:][:]) * diff_y(distance_matrix_1) + diff_y(Ulist[i][:][:]) * diff_y(distance_matrix_1)) \
                                                 - 1 / (h ** 2) * np.sum(
                            diff_x(Ulist[i][:][:]) * diff_y(distance_matrix_2) + diff_y(Ulist[i][:][:]) * diff_y(distance_matrix_2))
                    else:
                        signals[ind_sim, 0, k] = 0 

                    signals[ind_sim, 1, k] = i * delta_t

                    # ICD trace
                    if (i > ICD_time) & (i < ICD_time + np.int32(ICD_duration / delta_t)):
                        signals[ind_sim, 2, k] = ICD_amplitude
                    else:
                        signals[ind_sim, 2, k] = 0.0

            signals[ind_sim,0,:] = signals[ind_sim,0,:]/np.amax(signals[ind_sim,0,:])

        else:

            # load Ulist
            with open("initial_values" + os.sep + "Patient_" + str(idx + 1) + "_Ulist.npy", "rb") as fp:  # Unpickling
                Ulist = pickle.load(fp)
            # load Ut
            Ut = np.load("initial_values" + os.sep + "Patient_" + str(idx + 1) + "_Ut.npy", allow_pickle=True)
            # load Wt
            Wt = np.load("initial_values" + os.sep + "Patient_" + str(idx + 1) + "_Wt.npy", allow_pickle=True)


            for i in tqdm(range(int(450/delta_t), max_iter_time)):

                if ((i > -1) & (i < 1 + np.int32(2 / delta_t))) | \
                        ((i > np.int32(200 / delta_t)) & (i < np.int32(202 / delta_t))):
                    # coeff_init = ((128/N)**2)*10.0*0.02/delta_t
                    coeff_init = 10.0
                else:
                    coeff_init = 0.0

                # extra-stim-> [322, 324]
                if (i > S2) & (i < S2 + np.int32(2 / delta_t)):
                    # coeff = ((128/N)**2)*100.0*0.02/delta_t
                    coeff = 100.0
                else:
                    coeff = 0.0

                # ATP impulse-> [460, 460+durata ICD(5)]
                if (i > ICD_time) & (i < ICD_time + np.int32(ICD_duration / delta_t)):
                    # coeff_ICD = ICD_amplitude*((128/N)**2)*100.0*0.02/delta_t
                    coeff_ICD = 100
                else:
                    coeff_ICD = 0.0

                # nonlinear terms
                I_ion = nu_0 * Ut * (1.0 - Ut / v_th) * (1.0 - Ut / v_pk) + nu_1 * Wt * Ut  # Roger-McCulloch model for the ionic current
                g_ion = nu_2 * (Ut / v_pk - nu_3 * Wt) 

                # update the solution
                Ut = Ut + delta_t * (Dr * D_2 * laplace(Ut) + Dr * (D_1 - D_2) * laplace_fiber(Ut) \
                                     - I_ion + coeff_init * IappIC + coeff * Iapp + coeff_ICD * IappICD)
                Wt = Wt + delta_t * g_ion

                # ghost nodes
                tmp_u = Ut.numpy()

                tmp_u[0, :] = tmp_u[2, :]
                tmp_u[N - 1, :] = tmp_u[N - 3, :]
                tmp_u[:, 0] = tmp_u[:, 2]
                tmp_u[:, M - 1] = tmp_u[:, M - 3]

                Ut = tf.Variable(tmp_u)

                Ulist.append(Ut)
                k = np.int32(i / scaling_factor)
                if (np.mod(i, scaling_factor) == 0):
                    # pseudo ECG
                    if i >= starting_time_ecg/delta_t:

                        signals[ind_sim, 0, k] = 1 / (h ** 2) * np.sum(
                            diff_x(Ulist[i][:][:]) * diff_y(distance_matrix_1) + diff_y(Ulist[i][:][:]) * diff_y(
                                distance_matrix_1)) \
                                                 - 1 / (h ** 2) * np.sum(
                            diff_x(Ulist[i][:][:]) * diff_y(distance_matrix_2) + diff_y(Ulist[i][:][:]) * diff_y(
                                distance_matrix_2))
                    else:
                        signals[ind_sim, 0, k] = 0

                    signals[ind_sim, 1, k] = i * delta_t

                    # ICD trace
                    if (i > ICD_time) & (i < ICD_time + np.int32(ICD_duration / delta_t)):
                        signals[ind_sim, 2, k] = ICD_amplitude
                    else:
                        signals[ind_sim, 2, k] = 0.0

            signals[ind_sim, 0, :] = signals[ind_sim, 0, :] / np.amax(signals[ind_sim, 0, :])

    return signals
    

